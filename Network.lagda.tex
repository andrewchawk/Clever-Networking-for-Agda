\documentclass{report}

% The coloring distracts the author.
\usepackage[bw]{agda}

\title{\AgdaModule{Network}: An Extensible and Expressive but Slightly Clever Agda Module for the Representation of Various Entities in Computer Networking}

\begin{document}
\maketitle{}

\begin{abstract}
The author presents and explains \AgdaModule{Network}, which is an Agda representation of network packets and connections.  Notable properties of \AgdaModule{Network} include extensibility, expressive typing for protocols and packets, real-world examples, and at least some degree of formal verification.  However, \AgdaModule{Network} \emph{cannot} be directly used to actually establish network connections in the real world; \AgdaModule{Network} is a \texttt{--safe} module and, therefore, does not refer to \AgdaDatatype{IO}, which would be necessary for such establishment.
\end{abstract}

\chapter{Boilerplate Stuff}
This section contains the declaration of the name of this module and some import statements.  These things would not fit too well in any other part of the document.

\section{Options}
First and foremost --- actually, at this point in time, this option is the only one --- this document is safe, i.e., does not make use of postulates or any such nonsense.

\begin{code}
{-# OPTIONS --safe #-}
\end{code}

\section{Module Declaration}
The Agda parts of this paper constitute an Agda module.  Some submodules also exist.

\begin{code}
module Network where
\end{code}

\section{Imported Packages}
The author wishes to \emph{not} rewrite \emph{all} utilities.

\begin{code}
import Data.String

open import Data.Fin using (Fin; toℕ)
open import Data.String using (String)
open import Data.Nat
open import Data.List
open import Data.Maybe
open import Data.Bool
open import Data.Product
\end{code}

\part{The Core Types}
To prevent name clashes, this part constitutes an Agda module.

\begin{code}
module Core where
\end{code}

\chapter{Representation of Protocols}
Formally, where \(P\) is a certain subset of networking protocols, \(P\) is characterized by being such that for all elements \(p\) of \(P\), \(p\) can be represented as the combination of a type for network addresses for \(p\), a type for network ports for \(p\), although \(p\) might not explicitly use network ports, and a type for \(p\) packets.  Additionally, any such \(p\) probably has a name, and the name might even be an abbreviation, which could be convenient.

\AgdaRecord{Protocol} is an extension of this representation; where \AgdaBound{p} is some \AgdaRecord{Protocol} value, \AgdaField{Protocol.name} \AgdaBound{p} is a long name of the \AgdaBound{p} protocol, \AgdaField{Protocol.shortName} \AgdaBound{p} is, optionally, an abbreviation of the long name of the \AgdaBound{p} protocol, \AgdaField{Protocol.addressType} \AgdaBound{p} is the type of network addresses which are used by the \AgdaBound{p} protocol, and \AgdaField{Protocol.packetType} \AgdaBound{p} is the type of all packets in the \AgdaBound{p} protocol.

\begin{code}
  record Protocol : Set1 where
    field
      name : String
      shortName : Maybe String
      addressType : Set
      packetType : Set
\end{code}

\section{Can \AgdaRecord{Protocol} Unambiguously Represent \emph{Any} Network Protocol?}
\AgdaRecord{Protcol} is good for representing many sorts of protocols but may be incapable of unambiguously representing all imaginable protocols; the author is uncertain of a formal definition of ``network protocol'', and awareness of such a definition would facilitate defining a thing which resembles \AgdaRecord{Protocol} but an really be used to represent \emph{any} network protocol.  The author \emph{may} conduct some more research into the idea of network protocols but, in the meantime, thinks that \AgdaRecord{Protocol} should suffice for most purposes.

\chapter{Representation of Packets}
Without a representation of trasmissions, what is the usefulness of a system for representing protcols?  The author does not care and will define a datatype which facilitates representing the packets of any given protocol.

A packet \(p\) for a protocol \(P\) can be thought of as being a combination of the following attributes:
\begin{itemize}
	\item the \(P\) address of the sender of \(p\),
	\item the \(P\) address of the destination for \(p\), and
	\item the actual content or payload of \(p\).
\end{itemize}

The address type and content type are protocol-specific.  Fortunately, with dependent types, defining such a type is a simple process.  This paper's definition of an abstract packet is as follows:

\begin{code}
  record Packet (protocol : Protocol) : Set where
    field
      source
       destination : Protocol.addressType protocol
      content : Protocol.packetType protocol
\end{code}

For a given \AgdaRecord{Packet} \AgdaBound{P} value \AgdaBound{p}, the following statements hold:
\begin{itemize}
	\item \AgdaField{Packet.source} \AgdaBound{p} is the address of the sender of \AgdaBound{p}.
	\item \AgdaField{Packet.destination} \AgdaBound{p} is the address of the recipient of \AgdaBound{p}.
	\item \AgdaField{Packet.content} \AgdaBound{p} is the payload of \AgdaBound{p}.
\end{itemize}

\part{Specific Protocols}

\chapter{IPv4}
For the sake of brevity and general readability, within this example, the ``\AgdaModule{IPv4}'' prefix is omitted from the names of functions, constants, and such.

\begin{code}
module IPv4 where
\end{code}

RFC 791 describes version 4 of the Internet Protocol, which is also known as ``IPv4'', indicates that IPv4 addresses are 32-bit integers, and defines the IPv4 packet structure.  Specifically, RFC 791 indicates that any IPv4 packet \(p\) consists of the concatenation of the following fields:
\begin{enumerate}
	\item a four-bit version number,
	\item a four-bit definition of the length of the header which \emph{must} be greater than or equal to five,
	\item a six-bit differentiated services code point,
	\item a two-bit explicit congestion notification,
	\item a sixteen-bit integer which defines the total length of \(p\),
	\item a sixteen-bit identification field,
	\item a zero bit,
	\item a bit which indicates whether or not \(p\) must not be fragmented, with a one indicating that the packet must \emph{not} be fragmented},
	\item a bit which indicates whether or not \(p\) is the last of a series of fragmented packets,
	\item a thirteen-bit fragment offset field,
	\item an eight-bit time-to-live field,
	\item an eight-bit value which identifies the payload protocol,
	\item a sixteen-bit checksum of the header,
	\item a thirty-two-bit IPv4 address, indicating the source of \(p\),
	\item a thirty-two-bit IPv4 address, indicating the destination of \(p\),
	\item an options field whose length is calculable, and
	\item a payload of calculable length.
\end{enumerate}

A naive approach involves using \AgdaDatatype{Fin} for everything.  However, the author uses the term ``naive'' because the author prefers the alternative, which involves the use of more expressive datatypes which are specifically designed \emph{for} IPv4, although the \AgdaDatatype{Fin} approach really does work well for some fields.

\section{Addresses}
That at least two fields can be absent from the \AgdaField{Protocol.packetType} type may be immediately obvious; \AgdaRecord{Protocol} has native support for address schemes.  At this point, an IPv4 address type should probably be created, so the author \emph{has} gone and created such a type!  Specifically, the type is \AgdaFunction{Address}, which is defined as follows:

\begin{code}
  Address : Set
  Address = Fin (2 ^ 32)
\end{code}

The definition of \AgdaFunction{Address} follows pretty directly from the RFC's definition of IPv4 addresses; \AgdaDatatype{Fin} \AgdaSymbol(\AgdaNumber{2} \AgdaOperator{\AgdaFunction{^}} \AgdaBound{x}\AgdaSymbol) is the type of the \AgdaBound{x}-bit natural numbers.

\section{The Header Length Field}
Naively, one can say that the header length field is the combination of an appropriate \AgdaDatatype{Fin} number \(n\) and a proof which indicates that \(n \geq 5\).  In this case, the author actually \emph{likes} the naive approach.

\begin{code}
  IHL : Set
  IHL = Σ (Fin (2 ^ 4)) (\ n -> toℕ n ≥ 5)
\end{code}

\section{The Three Option Bits}
An approach to representing the three option bits which yields a not-particularly-readable result involves the use of \AgdaDatatype{Fin} \AgdaSymbol(\AgdaNumber{2} \AgdaOperator{\AgdaFunction{\circumflex}} \AgdaNumber{3}\AgdaSymbol).  However, the option bits an instead be represented as dedicated \AgdaDatatype{Bool} fields in a record type; this approach offers significantly more readability and prevents confusing the purposes of the individual option bits.

\section{Payload Protocol}
The author suspects that the reader can predict the naive solution; accordingly, to preserve the author's dwindling sanity, the author will refrain from describing the naive approach.  The author's preferred approach involves defining a datatype which \emph{readably} represents the protocols which can be indicated by the payload protocol field.  The definition of the datatype is as follows:

\begin{code}
  data PayloadProtocol : Set
    where
    HOPOPT
     ICMP
     IGMP
     GGP
     IP-in-IP
     ST
     TCP
     CBT
     EGP
     IGP
     BBN-RCC-MON
     NVP-II
     PUP
     ARGUS
     EMCON
     XNET
     CHAOS
     UDP
     MUX
     CDN-MEAS
     HMP
     PRM
     XNS-IDP
     TRUNK-1
     TRUNK-2
     LEAF-1
     LEAF-2
     RDP
     IRTP
     ISO-TP4
     NETBLT
     MFE-NSP
     MERIT-INP
     DCCP
     3PC
     IDPR
     XTP
     DDP
     IDPR-CMTP
     TP++
     IL
     IPv6
     SDRP
     IPv6-Route
     IPv6-Frag
     IDRP
     RSVP
     GRE
     DSR
     BNA
     ESP
     AH
     I-NLSP
     SwlPe
     NARP
     MOBILE
     TLSP
     SKIP
     IPv6-ICMP
     IPv6-NoNxt
     IPv6-Opts
     HostInternalProtocol
     CFTP
     LocalNetwork
     SAT-EXPAK
     KRYPTOLAN
     RVD
     IPPC
     DistributedFileSystem
     SAT-MON
     VISA
     IPCU
     CPNX
     CPHB
     WSN
     PVP
     BR-SAT-MON
     SUN-ND
     WB-MON
     WB-EXPAK
     ISO-IP
     VMTP
     SECURE-VMTP
     VINES
     TTP
     IPTM
     NSFNET-IGP
     DGP
     TCF
     EIGRP
     OSPF
     Sprite-RPC
     LARP
     MTP
     AX-25
     OS
     MICP
     SCC-SP
     ETHERIP
     ENCAP
     PrivateEncryption
     GMTP
     IFMP
     PNNI
     PIM
     ARIS
     SCPS
     QNX
     A/N
     IPComp
     SNP
     Compaq-Peer
     IPX-in-IP
     VRRP
     PGM
     ZeroHop
     L2TP
     DDX
     IATP
     STP
     SRP
     UTI
     SMP
     SM
     PTP
     IS-IS-over-IPv4
     FIRE
     CRTP
     CRUDP
     SSCOPMCE
     IPLT
     SPS
     PIPE
     SCTP
     FC
     RSVP-E2E-IGNORE
     MobilityHeader
     UDPLite
     MPLS-in-IP
     manet
     HIP
     Shim6
     WESP
     ROHC
     Ethernet
     AGGFRAG
     NSH : PayloadProtocol
    Unassigned : Fin 107 -> PayloadProtocol
    Experimental : Fin 2 -> PayloadProtocol
\end{code}

The author hopes that the meanings of the names of most constructors of arity 0 are obvious.  However, the author \emph{will} clarify that \AgdaInductiveConstructor{AX-25} corresponds to AX.25.  The author will \emph{also} clarify that \AgdaInductiveConstructor{Unassigned} \AgdaBound{n} is the \(k\)th IP protocol nmber, where \(k\) is defined to be equal to \AgdaNumber{146} \AgdaOperator{\AgdaFunction{+}} \AgdaFunction{toℕ} \AgdaBound{n}.

\subsection{Downside}
The main downside of this representation is the number of lines which are necessary for this description.  But the author still prefers \emph{this} solution over the naive solution, which is relatively unreadable and is \emph{still} left as an exercise for the reader.

\subsection{IPv6-Specific Values}
Some \AgdaDatatype{PayloadProtocol} contructors, e.g., \AgdaInductiveConstructor{Ethernet}, are actually specific to IPv6.  However, IPv6 and IPv4 use the same IP protocol numbers, and the author does not believe that listing all such protocol numbers is in any real way problematic.

\section{The Packet Record}
Armed with the preceding information, a type \AgdaRecord{Packet} can be decently easily defined such that for all \AgdaBound{p} of type \AgdaRecord{Packet}, the following statements hold:
\begin{itemize}
	\item \AgdaField{Packet.versionNumber} \AgdaBound{p} is the version number for the \AgdaField{p} packet.
	\item \AgdaField{Packet.headerLength} \AgdaBound{p} is the combination of a four-bit number \(l\), which is the length of the header of the \AgdaBound{p} packet, and a value which guarantees that \(l \geq 5\).
	\item \AgdaField{Packet.differentiatedServices} \AgdaBound{p} is the differentiated services code point for the \AgdaBound{p} packet.
	\item \AgdaField{Packet.congestionNotification} \AgdaBound{p} is the explicit congestion notification for the \AgdaBound{p} packet.
	\item \AgdaField{Packet.totalLength} \AgdaBound{p} is the total length of the \AgdaBound{p} packet.
	\item \AgdaField{Packet.identification} \AgdaBound{p} is the raw content of the identification field of the \AgdaBound{p} packet.
	\item \AgdaField{Packet.firstFlagBit} \AgdaBound{p} is \emph{reserved} and should be set to \AgdaInductiveConstructor{Fin.zero}.
	\item \AgdaField{Packet.dontFragment} \AgdaBound{p} is true if and only if the \AgdaBound{p} packet \emph{must not} be fragmented into additional packets.
	\item \AgdaField{Packet.moreFragments} \AgdaBound{p} is false if and only if the \AgdaBound{p} packet is the last of a series of fragmented packets or is a standalone packet.
	\item \AgdaField{Packet.fragmentOffset} \AgdaBound{p}
	\item \AgdaField{Packet.timeToLive} \AgdaBound{p}
	\item \AgdaField{Packet.protocol} \AgdaBound{p} is the protocol of \AgdaField{Packet.payload} \AgdaBound{p}.
	\item \AgdaField{Packet.headerChecksum} \AgdaBound{p} is the checksum of the header of the \AgdaBound{p} packet.
	\item \AgdaField{Packet.options} \AgdaBound{p} is the raw options field for the \AgdaBound{p} packet.
	\item \AgdaField{Packet.payload} \AgdaBound{p} is the payload of the \AgdaBound{p} packet.
\end{itemize}

\begin{code}
  record Packet : Set where
    field
      versionNumber : Fin (2 ^ 4)
      headerLength : IHL
      differentiatedServices : Fin (2 ^ 6)
      congestionNotification : Fin (2 ^ 2)
      totalLength : Fin (2 ^ 16)
      identification : Fin (2 ^ 16)
      firstOptionBit : Bool
      dontFragment : Bool
      moreFragments : Bool
      fragmentOffset : Fin (2 ^ 13)
      timeToLive : Fin (2 ^ 8)
      protocol : PayloadProtocol
      headerChecksum : Fin (2 ^ 16)
      options : Fin (2 ^ (toℕ (proj₁ headerLength) ∸ 5))
      payload : Fin (2 ^ toℕ totalLength ∸ toℕ (proj₁ headerLength))
\end{code}

\subsection{On \AgdaField{Packet.payload}}
The current typing scheme does \emph{not} ensure that for any appropriate \AgdaBound{p}, \AgdaField{Packet.protocol} \AgdaBound{p} actually describes the structure of \AgdaField{Packet.payload} \AgdaBound{p}; the \AgdaField{Packet.protocol} type is just a dumb \AgdaDatatype{Fin} type.  However, as indicated by the use of ``current'', this bit of information may eventually become outdated; such indication is strictly intentional.

\section{The Protocol Record}
With this information, the IPv4 protocol can be considered to have the following characteristics:
\begin{itemize}
	\item The long name of IPv4 is ``Internet Protocol version 4''.
	\item IPv4 has a short name.  This short name is, obviously, ``IPv4''.
	\item IPv4 addresses are 32-bit numbers, which are represented by \AgdaFunction{Address}.
\end{itemize}

Accordingly, the IPv4 protocol can be defined with an \AgdaRecord{Core.Protocol} record as follows:

\begin{code}
  protocol : Core.Protocol
  protocol = record
    {name = "Internet Protocol version 4"
    ;shortName = just "IPv4"
    ;addressType = Address
    ;packetType = Packet
    }
\end{code}

\section{The Addressful Packet Type}
Really, because \AgdaRecord{Core.Packet} exists, no explicit definition of a type for addressful IPv4 packets is necessary.  For any appropriate \AgdaBound{p}, \AgdaRecord{Core.Packet} \AgdaBound{p} is the type of packets which adhere to the \AgdaBound{p} protocol, and \AgdaFunction{protocol} is a description of the IPv4 protocol; therefore, \AgdaRecord{Core.Packet} \AgdaFunction{protocol} is the type of IPv4 packets.
\end{document}
