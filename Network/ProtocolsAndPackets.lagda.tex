\documentclass{report}

% The coloring distracts the author.
\usepackage[bw]{agda}

\title{\AgdaModule{Network.ProtocolsAndPackets}: An Extensible and Expressive but Slightly Clever Agda Module for the Representation of Protocols and Packets for Networks}

\begin{document}
\maketitle{}

\begin{abstract}
The author presents and explains \AgdaModule{Network.ProtocolsAndPackets}, which defines Agda representations of network packets and connections.  Notable properties of \AgdaModule{Network.ProtocolsAndPackets} include extensibility, expressive typing for protocols and packets, real-world examples, and at least some degree of formal verification.  However, \AgdaModule{Network.ProtocolsAndPackets} \emph{cannot} be directly used to actually establish network connections in the real world; \AgdaModule{Network.ProtocolsAndPackets} is a \texttt{--safe} module and, therefore, does not refer to \AgdaDatatype{IO}, which would be necessary for such establishment.
\end{abstract}

\chapter{Boilerplate Stuff}
This section contains the declaration of the name of this module and some import statements.  These things would not fit too well in any other part of the document.

\section{Options}
First and foremost --- actually, at this point in time, this option is the only one --- this document is safe, i.e., does not make use of postulates or any such nonsense.

\begin{code}
{-# OPTIONS --safe #-}
\end{code}

\section{Module Declaration}
The Agda parts of this paper constitute an Agda module.  Some submodules also exist.

\begin{code}
module Network.ProtocolsAndPackets where
\end{code}

\section{Imported Packages}
The author wishes to \emph{not} rewrite \emph{all} utilities.

\begin{code}
import Data.String
import Data.Maybe.Relation.Unary.Any as DataMaybe using (Any)

open import Function
open import Relation.Binary.HeterogeneousEquality
open import Data.Fin using (Fin; toℕ)
open import Data.String using (String)
open import Data.Nat
open import Data.List
open import Data.Unit.Polymorphic
open import Relation.Nullary
open import Data.Maybe
open import Data.Bool
open import Data.Product
open import Data.List.Relation.Unary.All using (All)
open import Data.List.Relation.Unary.Any using (Any)
open import Level using (Level)
\end{code}

\part{The Core Types}
To prevent name clashes, this part constitutes an Agda module.

\begin{code}
module Core where
\end{code}

\chapter{Representation of Protocols}
Formally, where \(P\) is a certain subset of networking protocols, \(P\) is characterized by being such that for all elements \(p\) of \(P\), \(p\) can be represented as the combination of a type for network addresses for \(p\), a type for network ports for \(p\), although \(p\) might not explicitly use network ports, and a type for \(p\) packets.  Additionally, any such \(p\) probably has a name, and the name might even be an abbreviation, which could be convenient.

\AgdaRecord{Protocol} is an extension of this representation; where \AgdaBound{p} is some \AgdaRecord{Protocol} \AgdaBound{l} value, the following statements hold:
\begin{itemize}
  \item \AgdaField{Protocol.name} \AgdaBound{p} is a long name of the \AgdaBound{p} protocol.
  \item \AgdaField{Protocol.shortName} \AgdaBound{p} is, optionally, an abbreviation of the long name of the \AgdaBound{p} protocol.
  \item If applicable, \AgdaField{Protocol.addressType} \AgdaBound{p} contains the type of network addresses which are used by the \AgdaBound{p} protocol.
  \item \AgdaField{Protocol.headerType} \AgdaBound{p} is the type of all headers for packets in the \AgdaBound{p} protocol.
  \item \AgdaField{Protocol.isSerialized} \AgdaBound{p} is \AgdaInductiveConstructor{true} if and only if all \AgdaBound{p} packets have serialized equivalents.
\end{itemize}

\begin{code}
  interleaved mutual
    record Protocol (l : Level) : Set (Level.suc l) where
      inductive
      field
        name : String
        shortName : Maybe String
        addressType : Maybe Set
        headerType : Set l
        isSerialized : Bool
\end{code}

\section{Can \AgdaRecord{Protocol} Unambiguously Represent \emph{Any} Network Protocol?}
\AgdaRecord{Protcol} is good for representing many sorts of protocols but may be incapable of unambiguously representing all imaginable protocols; the author is uncertain of a formal definition of ``network protocol'', and awareness of such a definition would facilitate defining a thing which resembles \AgdaRecord{Protocol} but an really be used to represent \emph{any} network protocol.  The author \emph{may} conduct some more research into the idea of network protocols but, in the meantime, thinks that \AgdaRecord{Protocol} should suffice for most purposes.

\chapter{Representation of Packets}
Without a representation of trasmissions, what is the usefulness of a system for representing protcols?  The author does not care and will define a datatype which facilitates representing the packets of any given protocol.

A packet \(p\) for a protocol \(P\) can be thought of as being a combination of the following attributes:
\begin{itemize}
  \item the \(P\) address of the sender of \(p\),
  \item the \(P\) address of the destination for \(p\),
  \item the payload of \(p\), and
  \item the actual content or payload of \(p\).
\end{itemize}

The address type and content type are protocol-specific.  Fortunately, with dependent types, defining such a type is a simple process.  This paper's definition of an abstract packet is as follows:

\begin{code}
    record UPacket {l : Level} (protocol : Protocol l) : Set (Level.suc l) where
      inductive
      field
        source
         destination : maybe (\ n -> n) ⊤ (Protocol.addressType protocol)
        payloadProtocol : Protocol l
        payload : UPacket payloadProtocol
\end{code}

For a given \AgdaRecord{UPacket} \AgdaBound{P} value \AgdaBound{p}, the following statements hold:
\begin{itemize}
  \item \AgdaField{UPacket.source} \AgdaBound{p} is the address of the sender of \AgdaBound{p}.
  \item \AgdaField{UPacket.destination} \AgdaBound{p} is the address of the recipient of \AgdaBound{p}.
  \item \AgdaField{UPacket.payload} \AgdaBound{p} is the payload of \AgdaBound{p}, which adheres to the \AgdaField{UPacket.payloadProtocol} \AgdaBound{p} protocol..
\end{itemize}

\section{Lack of Verification}
The reader might have noticed that that \AgdaRecord{UPacket} has few verification fields; really, \AgdaRecord{UPacket} only verifies that packets have serialized versions when such serialized versions are really necessary.  Records for formal verifications will be defined soon.

\section{The Name}
``\AgdaRecord{UPacket}'' is an abbreviation of \emph{something}, but the author does not certainly remember the nature of the abbreviation.  However, ``unverified'' and ``unsafe'' are reasonable expansions of the ``U'' in ``\AgdaRecord{UPacket}''.

\chapter{Representation of Sets of Interrelated Protocols}
A \AgdaRecord{ProtocolSet} record is a combination of a list of protocols and some guarantees about interaction between these protocols.  \AgdaRecord{ProtocolSet} enables indicating that interaction between protocols is verified such that no non-structly-positive nonsense is necessary.

Specifically, for any value \AgdaBound{ps} of type \AgdaRecord{ProtocolSet} \AgdaBound{l}, the following statements hold:
\begin{itemize}
  \item For any value \AgdaSymbol(\AgdaBound{protocol} \AgdaSymbol , \AgdaBound{possiblyProtocols}\AgdaSymbol) in \AgdaField{ProtocolSet.protocols} \AgdaBound{ps}, the following statements hold:
  \begin{itemize}
    \item If \AgdaBound{possiblyProtocols} is \AgdaInductiveConstructor{nothing}, then \emph{any} packet can encapsulate any packet of the \AgdaBound{protocol} protocol.
    \item If \AgdaBound{possiblyProtocols} is \AgdaInductiveConstructor{just} \AgdaBound{carrierProtocols}, then any \AgdaBound{carrierProtocols} packet can encapsulate any packet of the \AgdaBound{protocol} protocol.
  \end{itemize}
  \item \AgdaField{ProtocolSet.universalSerialize} \AgdaBound{ps} is, as indicated by the name, a universal packet serialization function for protocols which explicitly do serialization.  The use of ``universal'' also indicates that \emph{regardless of whether or not the \AgdaBound{P} protocol is actually allowed to carry the payload protocol}, \AgdaField{ProtocolSet.universalSerialize} \AgdaUnderscore{} \AgdaBound{P} \AgdaUnderscore{} \AgdaUnderscore{} \AgdaUnderscore{} is a serialized representation of the \AgdaBound{p} packet.
  \item \AgdaField{ProtocolSet.universalSerialize} \AgdaBound{ps} is, as \emph{this} name \emph{also} indicates, a universal packet \emph{de}serialization function for protocols which explicitly do serialization.  The use of ``universal'' \emph{also} indicates that \emph{regardless of whether or not the carrierprotocol is actually allowed to carry the payload protocol}, if and only if \AgdaBound{n} can be interpreted as representing some sort of appropriate packet, then \AgdaField{ProtocolSet.universalSerialize} \AgdaUnderscore{} \AgdaBound{n} contains a representation of the \AgdaBound{n} packet.
  \item \AgdaField{ProtocolSet.carrierUniqueness} \AgdaBound{ps} ensures that repeatedly defining the carriers of any single protocol is at worst\footnote{In this case, feasibility is a \emph{bad} thing!  Impossibility is ideal here.} infeasible.
  \item \AgdaField{ProtocolSet.carrierUniqueness} \AgdaBound{ps} ensures that for a given protocol \(p\) whose carrier protocols are explicitly enumerated, the list of carrier protocols for \(p\) contains no repetitions.   This type does not forbid much of consequence but does encourage clean definitions.
  \item \AgdaField{ProtocolSet.serialization-just} \AgdaBound{ps} ensures that if any protocol \(p\) supports a carrier protocol which demands serialization, then all \(p\) packets can be serialized.
  \item \AgdaField{ProtocolSet.standaloneAddresses} \AgdaBound{ps} ensures that any protocol which supports \emph{no} carrier protocols has some sort of address scheme.
  \item \AgdaField{ProtocolSet.deserialize-serialize-is-just} \AgdaBound{ps} ensures that the serialization function only outputs values which can be correctly deserialized by the deserialization function.
  \item \AgdaField{ProtocolSet.serialize-deserialize-is-just} \AgdaBound{ps} ensures that where for any packet's binary representation \(b\), the result of deserializing and reserializing \(b\) is the same old \(b\).
\end{itemize}

\begin{code}
  record ProtocolSet (l : Level) : Set (Level.suc l) where
    field
      protocols : List (Protocol l × Maybe (List (Protocol l)))
      universalSerialize :
        (P : Protocol l) ->
        (p : UPacket P) ->
        Protocol.isSerialized P ≅ true ->
        Protocol.isSerialized (UPacket.payloadProtocol p) ≅ true ->
        Σ ℕ Fin
      universalDeserialize : Σ ℕ Fin -> Maybe (Σ (Protocol l) UPacket)
      carriedUniqueness :
        (n n2 : Fin (length protocols)) ->
        ¬ n ≅ n2 ->
        ¬ lookup protocols n ≅ lookup protocols n2
      carrierUniqueness :
        (n : Fin (length protocols)) ->
        (isJust : Is-just (proj₂ (lookup protocols n))) ->
        let carriers = to-witness isJust in
        (m m2 : Fin (length carriers)) ->
        ¬ m ≅ m2 ->
        ¬ lookup carriers m ≅ lookup carriers m2
      serialization-just :
        All (\ p -> (isJust : Is-just (proj₂ p))
                 -> Any (_≅_ true ∘ Protocol.isSerialized)
                        (to-witness isJust)
                 -> true ≅ Protocol.isSerialized (proj₁ p))
            protocols
      standaloneAddresses :
        All (\ p -> (isJust : Is-just (proj₂ p))
                 -> length (to-witness isJust) ≅ 0
                 -> Is-just (Protocol.addressType (proj₁ p)))
            protocols
      deserialize-serialize-is-just :
        (P : Protocol l) ->
        (p : UPacket P) ->
        (sp : Protocol.isSerialized P ≅ true) ->
        (spP : Protocol.isSerialized (UPacket.payloadProtocol p) ≅ true) ->
        just p ≅
        universalDeserialize (universalSerialize P p sp spP)
      serialize-deserialize-is-identical :
        (n : Σ ℕ Fin) ->
        (parsingSucceeds : Is-just (universalDeserialize n)) ->
        let p = to-witness parsingSucceeds in
        (sp : Protocol.isSerialized (proj₁ p) ≅ true)
        (spP : Protocol.isSerialized (UPacket.payloadProtocol (proj₂ p)) ≅ true) ->
        universalSerialize _ (proj₂ p) sp spP ≅ n
\end{code}

\chapter{Representing Verified Packets}
For any value \AgdaBound{v} of type \AgdaRecord{Packet} \AgdaBound{p} \AgdaBound{s}, the following statements hold:
  \begin{itemize}
  \item \AgdaBound{v} is the combination of a representation of a packet of the \AgdaBound{p} protocol and some guarantees regarding this packet.  Some guarantees pertain to the interactions which are defined through \AgdaBound{s}.  Other guarantees pertain to\ldots{}\ well\ldots{}\ other stuff.
  \item \AgdaField{UPacket.rawPacket} \AgdaBound{v} represents the actual packet.
  \item \AgdaField{UPacket.mainProtocolExists} \AgdaBound{v} ensures that interactions with the main protocol of the packet are actually defined in the appropriate \AgdaRecord{ProtocolSet} record.
  \item \AgdaField{UPacket.carrierExists} \AgdaBound{v} ensures that \AgdaBound{s} actually supports the packet payload protocol.
  \item \AgdaField{UPacket.validCarrier-just} \AgdaBound{v} ensures that thr packet payload protocol actually supports being carried within packets for the \AgdaBound{p} protocol.
\end{itemize}

\begin{code}
  record Packet {l : Level}
                (protocol : Protocol l)
                (set : ProtocolSet l) :
                Set (Level.suc l)
    where
    field
      rawPacket : UPacket protocol
      mainProtocolExists :
        Any (_≅_ protocol)
            (Data.List.map proj₁ (ProtocolSet.protocols set))
      carrierExists :
        Σ (Fin (length (ProtocolSet.protocols set)))
          (\ n -> lookup (ProtocolSet.protocols set) n ≅
                 UPacket.payloadProtocol rawPacket)
      validCarrier-just  :
        (isJust : Is-just (proj₂ (lookup (ProtocolSet.protocols set)
                                         (proj₁ carrierExists)))) ->
        Any (_≅_ (UPacket.payloadProtocol rawPacket)) (to-witness isJust)
\end{code}

\part{Specific Protocols}

\begin{abstract}
Using \AgdaRecord{Protocol}, and the like, the author defines expressive representations of protocols and corresponding packets.
\end{abstract}

\chapter{IPv4}
This chapter defines a representation of IPv4.

\begin{code}
module IPv4 where
\end{code}

RFC 791 describes version 4 of the Internet Protocol, which is also known as ``IPv4'', indicates that IPv4 addresses are 32-bit integers, and defines the IPv4 packet structure.  Specifically, RFC 791 indicates that any IPv4 packet \(p\) consists of the concatenation of the following fields:
\begin{enumerate}
  \item a four-bit version number,
  \item a four-bit definition of the length of the header which \emph{must} be greater than or equal to five,
  \item a six-bit differentiated services code point,
  \item a two-bit explicit congestion notification,
  \item a sixteen-bit integer which defines the total length of \(p\),
  \item a sixteen-bit identification field,
  \item a zero bit,
  \item a bit which indicates whether or not \(p\) must not be fragmented, with a one indicating that the packet must \emph{not} be fragmented},
  \item a bit which indicates whether or not \(p\) is the last of a series of fragmented packets,
  \item a thirteen-bit fragment offset field,
  \item an eight-bit time-to-live field,
  \item an eight-bit value which identifies the payload protocol,
  \item a sixteen-bit checksum of the header,
  \item a thirty-two-bit IPv4 address, indicating the source of \(p\),
  \item a thirty-two-bit IPv4 address, indicating the destination of \(p\),
  \item an options field whose length is calculable, and
  \item a payload of calculable length.
\end{enumerate}

A naive approach involves using \AgdaDatatype{Fin} for everything.  However, the author uses the term ``naive'' because the author prefers the alternative, which involves the use of more expressive datatypes which are specifically designed \emph{for} IPv4, although the \AgdaDatatype{Fin} approach really does work well for some fields.

\section{Addresses}
That at least two fields can be absent from the \AgdaField{Protocol.packetType} type may be immediately obvious; \AgdaRecord{Protocol} has native support for address schemes.  At this point, an IPv4 address type should probably be created, so the author \emph{has} gone and created such a type!  Specifically, the type is \AgdaFunction{Address}, which is defined as follows:

\begin{code}
  Address : Set
  Address = Fin (2 ^ 32)
\end{code}

The definition of \AgdaFunction{Address} follows pretty directly from the RFC's definition of IPv4 addresses; \AgdaDatatype{Fin} \AgdaSymbol(\AgdaNumber{2} \AgdaOperator{\AgdaFunction{^}} \AgdaBound{x}\AgdaSymbol) is the type of the \AgdaBound{x}-bit natural numbers.

\section{The Header Length Field}
Naively, one can say that the header length field is the combination of an appropriate \AgdaDatatype{Fin} number \(n\) and a proof which indicates that \(n \geq 5\).  In this case, the author actually \emph{likes} the naive approach.

\begin{code}
  IHL : Set
  IHL = Σ (Fin (2 ^ 4)) (\ n -> toℕ n ≥ 5)
\end{code}

\section{The Three Option Bits}
An approach to representing the three option bits which yields a not-particularly-readable result involves the use of \AgdaDatatype{Fin} \AgdaSymbol(\AgdaNumber{2} \AgdaOperator{\AgdaFunction{\circumflex}} \AgdaNumber{3}\AgdaSymbol).  However, the option bits an instead be represented as dedicated \AgdaDatatype{Bool} fields in a record type; this approach offers significantly more readability and prevents confusing the purposes of the individual option bits.

\subsection{IPv6-Specific Values}
Some \AgdaDatatype{PayloadProtocol} contructors, e.g., \AgdaInductiveConstructor{Ethernet}, are actually specific to IPv6.  However, IPv6 and IPv4 use the same IP protocol numbers, and the author does not believe that listing all such protocol numbers is in any real way problematic.

\section{The Complete Header Record}
Armed with the preceding information, a type \AgdaRecord{Header} can be decently easily defined such that for all \AgdaBound{p} of type \AgdaRecord{Header}, the following statements hold:
\begin{itemize}
  \item \AgdaField{Header.versionNumber} \AgdaBound{p} is the version number for the \AgdaField{p} packet.
  \item \AgdaField{Header.headerLength} \AgdaBound{p} is the combination of a four-bit number \(l\), which is the length of the header of the \AgdaBound{p} packet, and a value which guarantees that \(l \geq 5\).
  \item \AgdaField{Header.differentiatedServices} \AgdaBound{p} is the differentiated services code point for the \AgdaBound{p} packet.
  \item \AgdaField{Header.congestionNotification} \AgdaBound{p} is the explicit congestion notification for the \AgdaBound{p} packet.
  \item \AgdaField{Header.totalLength} \AgdaBound{p} is the total length of the \AgdaBound{p} packet.
  \item \AgdaField{Header.identification} \AgdaBound{p} is the raw content of the identification field of the \AgdaBound{p} packet.
  \item \AgdaField{Header.firstFlagBit} \AgdaBound{p} is \emph{reserved} and should be set to \AgdaInductiveConstructor{Fin.zero}.
  \item \AgdaField{Header.dontFragment} \AgdaBound{p} is true if and only if the \AgdaBound{p} packet \emph{must not} be fragmented into additional packets.
  \item \AgdaField{Header.moreFragments} \AgdaBound{p} is false if and only if the \AgdaBound{p} packet is the last of a series of fragmented packets or is a standalone packet.
  \item \AgdaField{Header.fragmentOffset} \AgdaBound{p}
  \item \AgdaField{Header.timeToLive} \AgdaBound{p}
  \item \AgdaField{Header.headerChecksum} \AgdaBound{p} is the checksum of the header of the \AgdaBound{p} packet.
  \item \AgdaField{Header.options} \AgdaBound{p} is the raw options field for the \AgdaBound{p} packet.
\end{itemize}

\begin{code}
  record Header (l : Level) : Set (Level.suc l) where
    field
      versionNumber : Fin (2 ^ 4)
      headerLength : IHL
      differentiatedServices : Fin (2 ^ 6)
      congestionNotification : Fin (2 ^ 2)
      totalLength : Fin (2 ^ 16)
      identification : Fin (2 ^ 16)
      firstOptionBit : Bool
      dontFragment : Bool
      moreFragments : Bool
      fragmentOffset : Fin (2 ^ 13)
      timeToLive : Fin (2 ^ 8)
      headerChecksum : Fin (2 ^ 16)
      options : Fin (2 ^ (toℕ (proj₁ headerLength) ∸ 5))
\end{code}

\section{The Protocol Record}
With this information, the IPv4 protocol can be considered to have the following characteristics:
\begin{itemize}
  \item The long name of IPv4 is ``Internet Protocol version 4''.
  \item IPv4 has a short name.  This short name is, obviously, ``IPv4''.
  \item IPv4 addresses are 32-bit numbers, which are represented by \AgdaFunction{Address}.
\end{itemize}

Accordingly, the IPv4 protocol can be defined with an \AgdaRecord{Core.Protocol} record as follows:

\begin{code}
  protocol : (l : Level) -> Core.Protocol (Level.suc l)
  protocol l = record
    {name = "Internet Protocol version 4"
    ;shortName = just "IPv4"
    ;addressType = just Address
    ;isSerialized = true
    ;headerType = Header l
    }
\end{code}

\section{The Addressful Packet Type}
Really, because \AgdaRecord{Core.Packet} exists, no explicit definition of a type for addressful IPv4 packets is necessary.  For any appropriate \AgdaBound{p}, \AgdaRecord{Core.Packet} \AgdaBound{p} is the type of packets which adhere to the \AgdaBound{p} protocol, and \AgdaFunction{protocol} is a description of the IPv4 protocol; therefore, \AgdaRecord{Core.Packet} \AgdaFunction{protocol} is the type of IPv4 packets.
\end{document}
